use ark_ff::{Field, PrimeField, Zero};
use ark_poly::{DenseUVPolynomial, Polynomial};
use ark_poly::univariate::DensePolynomial;
use num_bigint::BigUint;
use num_integer::Integer;

trait FftDomain<F: Field> {
    fn fft(&self, coeffs: &[F]) -> Vec<F>;
    fn n(&self) -> usize;
    fn w(&self) -> F;
}

struct NaiveDomain<F: Field> {
    n: usize,
    w: F,
}

impl<F: Field> NaiveDomain<F> {
    fn new(w: F, n: usize) -> Self {
        assert!(w.pow([n as u64]).is_one());
        Self {
            n,
            w,
        }
    }
}

impl<F: Field> FftDomain<F> for NaiveDomain<F> {
    fn fft(&self, coeffs: &[F]) -> Vec<F> {
        assert_eq!(coeffs.len(), self.n);
        let poly = DensePolynomial::from_coefficients_slice(coeffs);
        let mut res = vec![F::zero(); self.n];
        res[0] = poly.evaluate(&F::one());
        res[1] = poly.evaluate(&self.w);
        let mut wi = self.w;
        for i in 2..self.n {
            wi *= self.w;
            res[i] = poly.evaluate(&wi);
        }
        res
    }

    fn n(&self) -> usize {
        self.n
    }

    fn w(&self) -> F {
        self.w
    }
}

struct CooleyTukeyDomain<F: Field, D1: FftDomain<F>, D2: FftDomain<F>> {
    n: usize,
    w: F,
    d1: D1,
    d2: D2,
    twiddles: Vec<Vec<F>>,
}

impl<F: Field, D1: FftDomain<F>, D2: FftDomain<F>> CooleyTukeyDomain<F, D1, D2> {
    fn new(w: F, d1: D1, d2: D2) -> Self {
        let n = d1.n() * d2.n();
        assert!(w.pow([n as u64]).is_one());
        let mut twiddles = vec![vec![F::zero(); d1.n()]; d2.n()];
        for i2 in 0..d2.n() {
            let mut inner = vec![F::zero(); d1.n()];
            for k1 in 0..d1.n() {
                inner[k1] = w.pow([(k1 * i2) as u64]);
            }
            twiddles[i2] = inner;
        }

        Self {
            n,
            w,
            d1,
            d2,
            twiddles,
        }
    }
}

impl<F: Field, D1: FftDomain<F>, D2: FftDomain<F>> FftDomain<F> for CooleyTukeyDomain<F, D1, D2> {
    fn fft(&self, coeffs: &[F]) -> Vec<F> {
        let n = self.n;
        let n1 = self.d1.n();
        let n2 = self.d2.n();
        assert_eq!(coeffs.len(), n);

        let mut inner_dfts = vec![vec![F::zero(); n2]; n1];
        for k1 in 0..n1 {
            let inner_coeffs: Vec<_> = coeffs.iter().cloned().skip(k1).step_by(n1).collect();
            assert_eq!(inner_coeffs.len(), n2);
            inner_dfts[k1] = self.d2.fft(&inner_coeffs);
        }

        let mut res = vec![F::zero(); n];
        for i2 in 0..n2 {
            let mut outer_coeffs = vec![F::zero(); n1];
            for k1 in 0..n1 {
                outer_coeffs[k1] = self.twiddles[i2][k1] * inner_dfts[k1][i2];
            }
            let outer_dft = self.d1.fft(&outer_coeffs);
            for i1 in 0..n1 {
                res[i1 * n2 + i2] = outer_dft[i1];
            }
        }
        res
    }

    fn n(&self) -> usize {
        self.n
    }

    fn w(&self) -> F {
        self.w
    }
}

struct RaderDomain<F: Field, D: FftDomain<F>> {
    // domain size, must be prime
    p: usize,
    // p-th root of unity
    w: F,
    // prime root modulo p
    g: usize,
    // domain of size p-1
    d: D,
    // domain generated by the inverse of d.w()
    d_inv: D,
    // g^i mod p, i=0,...,p-2
    perm: Vec<usize>,
    // iFFT of w^g^(-i), i=0,...,p-2
    b: Vec<F>,
}

impl<F: Field, D: FftDomain<F>> RaderDomain<F, D> {
    fn new(w: F, p: usize, g: usize, d: D, d_inv: D) -> Self {
        assert!(w.pow([p as u64]).is_one());
        let n = p - 1;
        assert_eq!(d.n(), n);
        assert_eq!(d_inv.n(), d.n());
        assert_eq!(d.w().inverse().unwrap(), d_inv.w());

        let mut perm = vec![1; n];
        for i in 1..n {
            perm[i] = (perm[i - 1] * g) % p
        }

        let mut ws = vec![F::one(); p];
        for i in 1..p {
            ws[i] = ws[i - 1] * w;
        }

        let mut b = vec![w; n];
        for i in 1..n {
            b[i] = ws[perm[n - i]];
        }

        let b = d.fft(&b);
        let n_inv = F::from(d.n() as u64).inverse().unwrap();
        let b = b.iter().map(|&b| b * n_inv).collect();

        Self {
            p,
            w,
            g,
            d,
            d_inv,
            perm,
            b,
        }
    }
}

impl<F: Field, D: FftDomain<F>> FftDomain<F> for RaderDomain<F, D> {
    fn fft(&self, coeffs: &[F]) -> Vec<F> {
        assert_eq!(coeffs.len(), self.p);
        let n = self.p - 1;
        let mut a = vec![F::zero(); n];
        for i in 0..n {
            a[i] = coeffs[self.perm[i]]
        }

        let a = self.d.fft(&a);
        let c: Vec<_> = a.into_iter().zip(self.b.iter()).map(|(a, b)| a * b).collect();
        let c = self.d_inv.fft(&c);

        let mut res = vec![F::zero(); self.p];
        res[0] = coeffs.iter().sum();
        res[1] = coeffs[0] + c[0];
        for i in 1..n {
            res[self.perm[n - i]] = coeffs[0] + c[i];
        }
        res
    }

    fn n(&self) -> usize {
        self.p
    }

    fn w(&self) -> F {
        self.w
    }
}

fn gen<F: PrimeField>(n: usize) -> F {
    let field_size: BigUint = F::MODULUS.into();
    let multiplicative_group_order = field_size - 1u8;
    let (cofactor, rem) = multiplicative_group_order.div_rem(&n.into());
    assert!(rem.is_zero());
    let cofactor: F::BigInt = cofactor.try_into().unwrap();
    let gen = F::GENERATOR.pow(cofactor);
    gen
}

#[cfg(test)]
mod tests {
    use ark_std::{end_timer, start_timer, test_rng, UniformRand};

    use super::*;

    #[test]
    fn test_cooley_tukey_2() {
        use ark_bls12_381::Fq;
        let rng = &mut test_rng();

        let n1 = 22;
        let n2 = 47;
        let n = n1 * n2;

        let w = gen::<Fq>(n);
        let w1 = w.pow([n2 as u64]);
        let w2 = w.pow([n1 as u64]);
        let d1 = NaiveDomain::new(w1, n1);
        let d2 = NaiveDomain::new(w2, n2);
        let fft_domain = CooleyTukeyDomain::new(w, d1, d2);
        let dft_domain = NaiveDomain::new(w, n);

        let coeffs: Vec<_> = (0..n).map(|_| Fq::rand(rng)).collect();

        let t_fft = start_timer!(|| format!("{}x{}-fft", n1, n2));
        let fft = fft_domain.fft(&coeffs);
        end_timer!(t_fft);

        let t_dft = start_timer!(|| format!("{}-dft", n));
        let dft = dft_domain.fft(&coeffs);
        end_timer!(t_dft);
        assert_eq!(fft, dft);
    }

    #[test]
    fn test_cooley_tukey_3() {
        use ark_bls12_381::Fq;
        let rng = &mut test_rng();

        let n1 = 2;
        let n2 = 11;
        let n3 = 47;
        let n = n1 * n2 * n3;

        let w = gen::<Fq>(n);
        let w1 = w.pow([(n2 * n3) as u64]);
        let w2 = w.pow([(n1 * n3) as u64]);
        let w3 = w.pow([(n1 * n2) as u64]);
        let d1 = NaiveDomain::new(w1, n1);
        let d2 = NaiveDomain::new(w2, n2);
        let d3 = NaiveDomain::new(w3, n3);
        let d12 = CooleyTukeyDomain::new(w.pow([n3 as u64]), d1, d2);
        let fft_domain = CooleyTukeyDomain::new(w, d12, d3);
        let dft_domain = NaiveDomain::new(w, n);

        let coeffs: Vec<_> = (0..n).map(|_| Fq::rand(rng)).collect();

        let t_fft = start_timer!(|| format!("{}x{}x{}-fft", n1, n2, n3));
        let fft = fft_domain.fft(&coeffs);
        end_timer!(t_fft);

        let t_dft = start_timer!(|| format!("{}-dft", n));
        let dft = dft_domain.fft(&coeffs);
        end_timer!(t_dft);
        assert_eq!(fft, dft);
    }

    // p - domain size
    // g = primitive_root(p)
    fn test_rader_no_padding(p: usize, g: usize) {
        use ark_bls12_381::Fq;
        let rng = &mut test_rng();

        let n = p - 1;
        let conv_domain_gen = gen::<Fq>(n);
        let conv_domain = NaiveDomain::new(conv_domain_gen, n);
        let conv_domain_inv = NaiveDomain::new(conv_domain_gen.inverse().unwrap(), n);
        let rader_domain = RaderDomain::new(gen::<Fq>(p), p, g, conv_domain, conv_domain_inv);
        let naive_domain = NaiveDomain::new(gen::<Fq>(p), p);

        let coeffs: Vec<_> = (0..p).map(|_| Fq::rand(rng)).collect();
        let rader_fft = rader_domain.fft(&coeffs);
        let naive_dft = naive_domain.fft(&coeffs);

        assert_eq!(rader_fft, naive_dft);
    }

    #[test]
    fn test_rader() {
        test_rader_no_padding(3, 2);
        test_rader_no_padding(23, 5);
        test_rader_no_padding(47, 5);
    }
}
